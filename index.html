<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Image Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">Image Editor</h1>
        
        <!-- Upload Section -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex items-center justify-center w-full">
                <label for="imageInput" class="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100">
                    <div class="flex flex-col items-center justify-center pt-5 pb-6">
                        <svg class="w-8 h-8 mb-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                        <p class="mb-2 text-sm text-gray-500">
                            <span class="font-semibold">Click to upload</span> or drag and drop
                        </p>
                        <p class="text-xs text-gray-500">PNG, JPG or JPEG</p>
                    </div>
                    <input id="imageInput" type="file" class="hidden" accept="image/*" />
                </label>
            </div>
        </div>

        <!-- Toolbar -->
        <div id="toolbar" class="bg-white rounded-lg shadow-md p-2 sm:p-4 mb-6 hidden">
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-4 gap-2">
                <h3 class="text-lg font-semibold text-gray-800">Tools</h3>
                <div class="flex flex-col sm:flex-row items-start sm:items-center gap-2 sm:space-x-4">
                    <label class="text-sm text-gray-600">Mode:</label>
                    <select id="editMode" class="px-3 py-1 border border-gray-300 rounded-md text-sm">
                        <option value="crop">Crop Mode</option>
                        <option value="draw">Draw Mode</option>
                    </select>
                </div>
            </div>
            
            <!-- Crop Controls -->
            <div id="cropControls" class="flex flex-col sm:flex-row items-start sm:items-center gap-2 sm:space-x-4 mb-4">
                <div class="flex items-center space-x-2">
                    <label class="text-sm text-gray-600">Zoom:</label>
                    <input id="zoomSlider" type="range" min="0.1" max="3" step="0.1" value="1" class="w-24">
                    <span id="zoomValue" class="text-sm text-gray-600">1x</span>
                </div>
                <button id="resetZoom" class="px-3 py-1 bg-gray-500 text-white rounded-md text-sm hover:bg-gray-600">Reset</button>
            </div>

            <!-- Drawing Controls -->
            <div id="drawControls" class="hidden">
                <div class="flex flex-wrap items-center gap-2 mb-4">
                    <label class="text-sm text-gray-600 w-full sm:w-auto">Drawing Tool:</label>
                    <button id="selectTool" class="px-3 py-2 bg-gray-400 text-white rounded-md text-sm hover:bg-gray-500 active-tool flex-1 sm:flex-none border-2 border-gray-600 shadow-lg">Select/Edit</button>
                    <button id="trayTool" class="px-3 py-2 bg-red-500 text-white rounded-md text-sm hover:bg-red-600 flex-1 sm:flex-none transition-all duration-200">Tray</button>
                    <button id="msTrunkingTool" class="px-3 py-2 bg-purple-500 text-white rounded-md text-sm hover:bg-purple-600 flex-1 sm:flex-none transition-all duration-200">MS Trunking</button>
                    <button id="hdgTrunkingTool" class="px-3 py-2 bg-green-600 text-white rounded-md text-sm hover:bg-green-700 flex-1 sm:flex-none transition-all duration-200">HDG Trunking</button>
                    <button id="giPipeTool" class="px-3 py-2 bg-orange-500 text-white rounded-md text-sm hover:bg-orange-600 flex-1 sm:flex-none transition-all duration-200">GI Pipe</button>
                    <button id="corrugatedPipeTool" class="px-3 py-2 bg-cyan-500 text-white rounded-md text-sm hover:bg-cyan-600 flex-1 sm:flex-none transition-all duration-200">Corrugated Pipe</button>
                    <button id="logoTool" class="px-3 py-2 bg-blue-600 text-white rounded-md text-sm hover:bg-blue-700 flex-1 sm:flex-none transition-all duration-200">Add Logo</button>
                    <button id="eraserTool" class="px-3 py-2 bg-yellow-500 text-white rounded-md text-sm hover:bg-yellow-600 flex-1 sm:flex-none transition-all duration-200">Eraser</button>
                    <button id="clearDrawing" class="px-3 py-2 bg-gray-500 text-white rounded-md text-sm hover:bg-gray-600 flex-1 sm:flex-none">Clear All</button>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 sm:space-x-4">
                <button id="exportImage" class="px-4 sm:px-6 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm sm:text-base">Export for Backend</button>
                <button id="generateProposal" class="px-4 sm:px-6 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm sm:text-base">Generate Proposal</button>
                <button id="resetCanvas" class="px-4 sm:px-6 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm sm:text-base">Reset</button>
            </div>
        </div>

        <!-- Canvas Container -->
        <div class="bg-white rounded-lg shadow-md p-2 sm:p-6">
            <div class="flex justify-center">
                <div id="canvasContainer" class="relative border-2 border-gray-300 rounded-lg overflow-hidden touch-none" style="max-width: 100%; width: 342px; height: 350px; min-width: 280px;">
                    <canvas id="fabricCanvas" width="342" height="350" style="max-width: 100%; height: auto; display: block; margin: 0 auto;"></canvas>
                    <!-- Legend Box -->
                    <div id="legendBox" class="absolute bottom-2 right-2 bg-white border border-gray-300 rounded-lg shadow-lg p-1.5 text-xs hidden" style="min-width: 80px;">
                        <div class="font-medium text-gray-700 mb-0.5 text-center text-xs">Legend</div>
                        <div id="legendContent"></div>
                    </div>
                </div>
            </div>
        </div>


        <!-- Info Panel -->
        <div id="infoPanel" class="bg-white rounded-lg shadow-md p-4 mt-6 hidden">
            <h3 class="text-lg font-semibold text-gray-800 mb-2">Instructions</h3>
            <div id="cropInstructions" class="text-sm text-gray-600">
                <p><strong>Crop Mode:</strong></p>
                <ul class="list-disc list-inside mt-1">
                    <li>Use the zoom slider to scale the image</li>
                    <li>Drag the image to position it within the crop area</li>
                    <li>The final crop will be 600x400 pixels</li>
                </ul>
            </div>
            <div id="drawInstructions" class="hidden text-sm text-gray-600">
                <p><strong>Draw Mode:</strong></p>
                <ul class="list-disc list-inside mt-1">
                    <li><strong>Select/Edit:</strong> Default mode for selecting and editing existing objects safely</li>
                    <li><strong>Drawing Tools:</strong> Select Tray (red), MS Trunking (purple), HDG Trunking (green), GI Pipe (orange), or Corrugated Pipe (cyan) to draw straight dashed lines</li>
                    <li><strong>Add Logo:</strong> Click anywhere to place the company logo</li>
                    <li><strong>Eraser:</strong> Click on objects to delete them</li>
                    <li>Click on existing objects to select and edit them (move/resize)</li>
                    <li>Press Delete key to remove selected objects</li>
                    <li>Use "Clear All" to remove all drawings</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas;
        let currentImage = null;
        let cropRect = null;
        let isDrawMode = false;
        let currentDrawTool = null;
        let originalImageData = null;
        let isEraserMode = false;
        let isLogoMode = false;
        let isSelectMode = true;
        
        // Fixed crop dimensions matching PowerPoint placeholder (9.05cm x 9.25cm)
        // At 96 DPI: 9.05cm ≈ 342px, 9.25cm ≈ 350px
        const CROP_WIDTH = 342;
        const CROP_HEIGHT = 350;

        // Initialize Fabric.js canvas
        function initCanvas() {
            canvas = new fabric.Canvas('fabricCanvas', {
                width: CROP_WIDTH,
                height: CROP_HEIGHT,
                backgroundColor: '#f8f9fa',
                enableRetinaScaling: false // Disable retina scaling to prevent offset issues
            });

            // Add crop rectangle (visual guide)
            cropRect = new fabric.Rect({
                left: 0,
                top: 0,
                width: CROP_WIDTH,
                height: CROP_HEIGHT,
                fill: 'transparent',
                stroke: '#3b82f6',
                strokeWidth: 2,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false,
                excludeFromExport: true
            });
            canvas.add(cropRect);

            // Canvas event listeners
            // Mouse and touch events
            canvas.on('mouse:down', handleMouseDown);
            canvas.on('mouse:move', handleMouseMove);
            canvas.on('mouse:up', handleMouseUp);
            
            // Touch events for mobile
            canvas.on('touch:gesture', function(e) {
                e.e.preventDefault();
                e.e.stopPropagation();
            });
            
            canvas.on('touch:drag', function(e) {
                if (isDrawMode) {
                    handleMouseMove(e);
                }
            });
            canvas.on('path:created', handlePathCreated);
            
            // Ensure canvas offset is calculated correctly
            setTimeout(() => {
                canvas.calcOffset();
            }, 100);
        }

        // Handle file upload
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    loadImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });

        // Load image onto canvas
        function loadImage(imageSrc) {
            fabric.Image.fromURL(imageSrc, function(img) {
                // Store original image data
                originalImageData = imageSrc;
                
                // Remove existing image if any
                if (currentImage) {
                    canvas.remove(currentImage);
                }

                // Scale image to fit within crop area initially
                const scaleX = CROP_WIDTH / img.width;
                const scaleY = CROP_HEIGHT / img.height;
                const scale = Math.min(scaleX, scaleY);
                
                img.set({
                    left: CROP_WIDTH / 2,
                    top: CROP_HEIGHT / 2,
                    originX: 'center',
                    originY: 'center',
                    scaleX: scale,
                    scaleY: scale
                });

                currentImage = img;
                canvas.add(img);
                canvas.sendToBack(img);
                canvas.bringToFront(cropRect);
                canvas.renderAll();

                // Show toolbar and info panel
                document.getElementById('toolbar').classList.remove('hidden');
                document.getElementById('infoPanel').classList.remove('hidden');
                
                // Update zoom slider
                document.getElementById('zoomSlider').value = scale;
                document.getElementById('zoomValue').textContent = scale.toFixed(1) + 'x';
                
                // Recalculate canvas offset after image load
                setTimeout(() => {
                    canvas.calcOffset();
                }, 100);
            });
        }

        // Mode switching
        document.getElementById('editMode').addEventListener('change', function(e) {
            const mode = e.target.value;
            isDrawMode = mode === 'draw';
            
            if (isDrawMode) {
                document.getElementById('cropControls').classList.add('hidden');
                document.getElementById('drawControls').classList.remove('hidden');
                document.getElementById('cropInstructions').classList.add('hidden');
                document.getElementById('drawInstructions').classList.remove('hidden');
                
                // Disable image selection and movement
                if (currentImage) {
                    currentImage.set({
                        selectable: false,
                        evented: false
                    });
                }
                
                // Enable custom drawing mode for straight lines
                canvas.isDrawingMode = false; // Disable fabric.js freeform drawing
                canvas.selection = true; // Allow selection of drawn lines
            } else {
                document.getElementById('cropControls').classList.remove('hidden');
                document.getElementById('drawControls').classList.add('hidden');
                document.getElementById('cropInstructions').classList.remove('hidden');
                document.getElementById('drawInstructions').classList.add('hidden');
                
                // Enable image selection and movement
                if (currentImage) {
                    currentImage.set({
                        selectable: true,
                        evented: true
                    });
                }
                
                canvas.isDrawingMode = false;
                canvas.selection = true;
            }
            canvas.renderAll();
        });

        // Zoom controls
        document.getElementById('zoomSlider').addEventListener('input', function(e) {
            const zoom = parseFloat(e.target.value);
            if (currentImage) {
                currentImage.set({
                    scaleX: zoom,
                    scaleY: zoom
                });
                canvas.renderAll();
                document.getElementById('zoomValue').textContent = zoom.toFixed(1) + 'x';
            }
        });

        document.getElementById('resetZoom').addEventListener('click', function() {
            if (currentImage) {
                const scaleX = CROP_WIDTH / (currentImage.width * currentImage.scaleX);
                const scaleY = CROP_HEIGHT / (currentImage.height * currentImage.scaleY);
                const scale = Math.min(scaleX, scaleY);
                
                currentImage.set({
                    scaleX: scale,
                    scaleY: scale,
                    left: CROP_WIDTH / 2,
                    top: CROP_HEIGHT / 2
                });
                canvas.renderAll();
                
                document.getElementById('zoomSlider').value = scale;
                document.getElementById('zoomValue').textContent = scale.toFixed(1) + 'x';
            }
        });

        // Drawing tool selection
        document.getElementById('selectTool').addEventListener('click', function() {
            currentDrawTool = null;
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = true;
            updateDrawToolUI();
        });

        document.getElementById('trayTool').addEventListener('click', function() {
            currentDrawTool = 'tray';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('msTrunkingTool').addEventListener('click', function() {
            currentDrawTool = 'msTrunking';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('hdgTrunkingTool').addEventListener('click', function() {
            currentDrawTool = 'hdgTrunking';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('giPipeTool').addEventListener('click', function() {
            currentDrawTool = 'giPipe';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('corrugatedPipeTool').addEventListener('click', function() {
            currentDrawTool = 'corrugatedPipe';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('logoTool').addEventListener('click', function() {
            isLogoMode = true;
            isEraserMode = false;
            isSelectMode = false;
            currentDrawTool = null;
            updateDrawToolUI();
        });

        document.getElementById('eraserTool').addEventListener('click', function() {
            isEraserMode = true;
            isLogoMode = false;
            isSelectMode = false;
            currentDrawTool = null;
            canvas.isDrawingMode = false; // Disable drawing mode for eraser
            updateDrawToolUI();
        });

        function getToolColor(tool) {
            switch(tool) {
                case 'tray': return '#ef4444'; // red
                case 'msTrunking': return '#8b5cf6'; // purple
                case 'hdgTrunking': return '#059669'; // green
                case 'giPipe': return '#f97316'; // orange
                case 'corrugatedPipe': return '#06b6d4'; // cyan
                default: return '#ef4444';
            }
        }

        function getToolName(tool) {
            switch(tool) {
                case 'tray': return 'Tray';
                case 'msTrunking': return 'MS Trunking';
                case 'hdgTrunking': return 'HDG Trunking';
                case 'giPipe': return 'GI Pipe';
                case 'corrugatedPipe': return 'Corrugated Pipe';
                default: return 'Unknown';
            }
        }

        function updateLegend() {
            const legendBox = document.getElementById('legendBox');
            const legendContent = document.getElementById('legendContent');
            
            if (!canvas) return;
            
            // Get all objects except background image and crop rectangle
            const objects = canvas.getObjects();
            const drawnObjects = objects.filter(obj => 
                obj !== cropRect && obj !== currentImage && 
                (obj.type === 'line' || obj.type === 'image')
            );
            
            if (drawnObjects.length === 0) {
                legendBox.classList.add('hidden');
                return;
            }
            
            // Group objects by type/color
            const legendItems = new Map();
            
            drawnObjects.forEach(obj => {
                if (obj.type === 'line') {
                    const color = obj.stroke;
                    let toolName = 'Unknown';
                    
                    // Match color to tool name
                    if (color === '#ef4444') toolName = 'Tray';
                    else if (color === '#8b5cf6') toolName = 'MS Trunking';
                    else if (color === '#059669') toolName = 'HDG Trunking';
                    else if (color === '#f97316') toolName = 'GI Pipe';
                    else if (color === '#06b6d4') toolName = 'Corrugated Pipe';
                    
                    if (!legendItems.has(toolName)) {
                        legendItems.set(toolName, { color, count: 0 });
                    }
                    legendItems.get(toolName).count++;
                } else if (obj.type === 'image' && obj !== currentImage) {
                    // This is a logo
                    if (!legendItems.has('Logo')) {
                        legendItems.set('Logo', { color: '#3b82f6', count: 0 });
                    }
                    legendItems.get('Logo').count++;
                }
            });
            
            // Build legend HTML
            let legendHTML = '';
            legendItems.forEach((item, name) => {
                if (name === 'Logo') {
                    legendHTML += `
                        <div class="flex items-center mb-0.5">
                            <div class="w-2.5 h-2.5 rounded-sm mr-1.5 border border-gray-400" style="background: linear-gradient(45deg, #3b82f6 25%, transparent 25%), linear-gradient(-45deg, #3b82f6 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #3b82f6 75%), linear-gradient(-45deg, transparent 75%, #3b82f6 75%); background-size: 3px 3px; background-position: 0 0, 0 1px, 1px -1px, -1px 0px;"></div>
                            <span class="text-gray-700 text-xs">${name}</span>
                        </div>`;
                } else {
                    legendHTML += `
                        <div class="flex items-center mb-0.5">
                            <div class="w-2.5 h-0.5 mr-1.5 border-dashed" style="background-color: ${item.color}; border: 1px dashed ${item.color};"></div>
                            <span class="text-gray-700 text-xs">${name}</span>
                        </div>`;
                }
            });
            
            legendContent.innerHTML = legendHTML;
            legendBox.classList.remove('hidden');
        }

        function updateDrawToolUI() {
            // Remove active styling from all tools
            document.querySelectorAll('#selectTool, #trayTool, #msTrunkingTool, #hdgTrunkingTool, #giPipeTool, #corrugatedPipeTool, #logoTool, #eraserTool').forEach(btn => {
                btn.classList.remove('active-tool', 'border-2', 'shadow-lg');
                btn.classList.add('transition-all', 'duration-200');
            });
            
            if (isSelectMode) {
                document.getElementById('selectTool').classList.add('active-tool', 'border-2', 'border-gray-600', 'shadow-lg');
                canvas.isDrawingMode = false;
                canvas.defaultCursor = 'default';
            } else if (isEraserMode) {
                document.getElementById('eraserTool').classList.add('active-tool', 'border-2', 'border-yellow-300', 'shadow-lg');
                canvas.isDrawingMode = false;
                canvas.defaultCursor = 'crosshair';
            } else if (isLogoMode) {
                document.getElementById('logoTool').classList.add('active-tool', 'border-2', 'border-blue-300', 'shadow-lg');
                canvas.isDrawingMode = false;
                canvas.defaultCursor = 'crosshair';
            } else if (currentDrawTool) {
                const toolButton = document.getElementById(currentDrawTool + 'Tool');
                if (toolButton) {
                    const borderColor = currentDrawTool === 'tray' ? 'border-red-300' : 
                                      currentDrawTool === 'msTrunking' ? 'border-purple-300' : 
                                      currentDrawTool === 'hdgTrunking' ? 'border-green-300' :
                                      currentDrawTool === 'giPipe' ? 'border-orange-300' :
                                      currentDrawTool === 'corrugatedPipe' ? 'border-cyan-300' :
                                      'border-gray-300';
                    toolButton.classList.add('active-tool', 'border-2', borderColor, 'shadow-lg');
                }
                canvas.isDrawingMode = false; // We handle drawing manually for straight lines
                canvas.defaultCursor = 'crosshair';
            }
        }

        // Drawing functionality
        let isDrawing = false;
        let startPoint = null;
        let currentLine = null;

        function handleMouseDown(e) {
            if (!isDrawMode) return;
            
            const pointer = canvas.getPointer(e.e);
            
            if (isSelectMode) {
                // Select mode - only allow selecting existing objects
                const target = canvas.findTarget(e.e, false);
                if (target && target !== cropRect && target !== currentImage) {
                    canvas.setActiveObject(target);
                    canvas.renderAll();
                } else {
                    canvas.discardActiveObject();
                    canvas.renderAll();
                }
                return;
            }
            
            if (isEraserMode) {
                // Eraser mode - find and remove clicked object
                const target = canvas.findTarget(e.e, false);
                if (target && (target.type === 'line' || target.type === 'image') && target !== cropRect && target !== currentImage) {
                    canvas.remove(target);
                    canvas.renderAll();
                    updateLegend(); // Update legend when object is removed
                }
                return;
            }
            
            if (isLogoMode) {
                // Logo mode - place logo at click position
                placeLogo(pointer.x, pointer.y);
                return;
            }
            
            // Drawing mode - check if clicking on existing object first
            const target = canvas.findTarget(e.e, false);
            if (target && target !== cropRect && target !== currentImage) {
                canvas.setActiveObject(target);
                canvas.renderAll();
                return;
            }
            
            // Start drawing new line only if we have a drawing tool selected
            if (currentDrawTool) {
                canvas.discardActiveObject();
                isDrawing = true;
                startPoint = { x: pointer.x, y: pointer.y };
                
                // Create temporary line for preview
                currentLine = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
                    stroke: getToolColor(currentDrawTool),
                    strokeWidth: 9,
                    strokeDashArray: [8, 4],
                    selectable: false,
                    evented: false,
                    opacity: 0.7
                });
                canvas.add(currentLine);
            }
        }

        function placeLogo(x, y) {
            // Try to load from file first
            fabric.Image.fromURL('./Timelogo.png', function(logoImg) {
                if (logoImg && logoImg.width > 0) {
                    addLogoToCanvas(logoImg, x, y);
                } else {
                    console.warn('Could not load logo from ./Timelogo.png, trying different approach...');
                    // Fallback: create a temporary file input to load logo
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*';
                    fileInput.style.display = 'none';
                    
                    fileInput.onchange = function(e) {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = function(event) {
                                fabric.Image.fromURL(event.target.result, function(logoImg) {
                                    addLogoToCanvas(logoImg, x, y);
                                });
                            };
                            reader.readAsDataURL(file);
                        }
                        document.body.removeChild(fileInput);
                    };
                    
                    document.body.appendChild(fileInput);
                    fileInput.click();
                }
            });
        }
        
        function addLogoToCanvas(logoImg, x, y) {
            // Scale the logo to a reasonable size (adjust as needed)
            const maxSize = 80; // Maximum width/height in pixels
            const scale = Math.min(maxSize / logoImg.width, maxSize / logoImg.height);
            
            logoImg.set({
                left: x,
                top: y,
                originX: 'center',
                originY: 'center',
                scaleX: scale,
                scaleY: scale,
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                cornerColor: '#fff',
                cornerStrokeColor: '#2563eb',
                borderColor: '#2563eb',
                cornerSize: 8
            });
            
            canvas.add(logoImg);
            canvas.bringToFront(logoImg);
            canvas.bringToFront(cropRect);
            canvas.setActiveObject(logoImg);
            canvas.renderAll();
            updateLegend(); // Update legend when logo is added
        }

        function handleMouseMove(e) {
            if (!isDrawMode || !isDrawing || isEraserMode || isLogoMode || isSelectMode || !currentLine) return;
            
            const pointer = canvas.getPointer(e.e);
            
            // Update preview line
            currentLine.set({
                x2: pointer.x,
                y2: pointer.y
            });
            canvas.renderAll();
        }

        function handleMouseUp(e) {
            if (!isDrawMode || !isDrawing || isEraserMode || isLogoMode || isSelectMode) return;
            
            const pointer = canvas.getPointer(e.e);
            isDrawing = false;
            
            if (currentLine && startPoint) {
                // Calculate minimum line length
                const distance = Math.sqrt(
                    Math.pow(pointer.x - startPoint.x, 2) + 
                    Math.pow(pointer.y - startPoint.y, 2)
                );
                
                // Remove preview line
                canvas.remove(currentLine);
                
                if (distance > 10) { // Minimum line length
                    // Create final dashed line
                    const toolColor = getToolColor(currentDrawTool);
                    const finalLine = new fabric.Line([startPoint.x, startPoint.y, pointer.x, pointer.y], {
                        stroke: toolColor,
                        strokeWidth: 9,
                        strokeDashArray: [8, 4],
                        selectable: true,
                        evented: true,
                        hasControls: true,
                        hasBorders: true,
                        cornerColor: '#fff',
                        cornerStrokeColor: toolColor,
                        borderColor: toolColor,
                        cornerSize: 8
                    });
                    
                    canvas.add(finalLine);
                    canvas.bringToFront(finalLine);
                    canvas.bringToFront(cropRect);
                    updateLegend(); // Update legend when line is added
                }
                
                canvas.renderAll();
            }
            
            currentLine = null;
            startPoint = null;
        }

        function handlePathCreated(e) {
            // No longer needed since we're creating straight lines manually
        }

        // Clear drawing
        document.getElementById('clearDrawing').addEventListener('click', function() {
            const objects = canvas.getObjects();
            const toRemove = objects.filter(obj => 
                (obj.type === 'line' || obj.type === 'path' || obj.type === 'Path') && obj !== cropRect && obj !== currentImage
            );
            toRemove.forEach(obj => canvas.remove(obj));
            canvas.renderAll();
            updateLegend(); // Update legend when all objects are cleared
        });

        // Export functionality
        document.getElementById('exportImage').addEventListener('click', function() {
            if (!currentImage) return;
            
            // Temporarily hide crop rectangle
            cropRect.visible = false;
            canvas.renderAll();
            
            // Export the canvas
            const exportData = {
                imageData: canvas.toDataURL('image/png'),
                cropDimensions: {
                    width: CROP_WIDTH,
                    height: CROP_HEIGHT
                },
                originalImage: originalImageData,
                timestamp: new Date().toISOString()
            };
            
            // Show crop rectangle again
            cropRect.visible = true;
            canvas.renderAll();
            
            // For now, just log the export data (later will be sent to backend)
            console.log('Export data ready for backend:', exportData);
            
            // Create download link for testing
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = exportData.imageData;
            link.click();
            
            alert('Image exported! Check console for backend data and download should start.');
        });

        // Reset canvas
        document.getElementById('resetCanvas').addEventListener('click', function() {
            canvas.clear();
            currentImage = null;
            originalImageData = null;
            
            // Re-add crop rectangle
            cropRect = new fabric.Rect({
                left: 0,
                top: 0,
                width: CROP_WIDTH,
                height: CROP_HEIGHT,
                fill: 'transparent',
                stroke: '#3b82f6',
                strokeWidth: 2,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false,
                excludeFromExport: true
            });
            canvas.add(cropRect);
            canvas.setBackgroundColor('#f8f9fa', canvas.renderAll.bind(canvas));
            
            // Hide toolbar and legend
            document.getElementById('toolbar').classList.add('hidden');
            document.getElementById('infoPanel').classList.add('hidden');
            document.getElementById('legendBox').classList.add('hidden');
            
            // Reset form
            document.getElementById('imageInput').value = '';
        });
        
        // Function to combine canvas with legend overlay
        async function getCanvasWithLegend() {
            return new Promise((resolve) => {
                // Create a temporary canvas to combine canvas + legend
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Set same dimensions as original canvas
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                
                // First, draw the original canvas content
                const canvasImage = new Image();
                canvasImage.onload = function() {
                    tempCtx.drawImage(canvasImage, 0, 0);
                    
                    // Check if legend is visible
                    const legendBox = document.getElementById('legendBox');
                    if (!legendBox.classList.contains('hidden')) {
                        console.log('📋 Adding legend to canvas image...');
                        
                        // Get legend content and styling
                        const legendContent = document.getElementById('legendContent');
                        const legendItems = legendContent.children;
                        
                        // Position for legend (bottom right with padding) - more compact
                        const legendWidth = 85; // Reduced from 110
                        const legendHeight = legendItems.length * 18 + 22; // Reduced spacing
                        const legendX = tempCanvas.width - legendWidth - 8; // 8px from right
                        const legendY = tempCanvas.height - legendHeight - 8; // 8px from bottom
                        
                        // Draw legend background (white rounded box with border)
                        tempCtx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        tempCtx.strokeStyle = '#d1d5db';
                        tempCtx.lineWidth = 1;
                        
                        // Draw rounded rectangle
                        const cornerRadius = 6;
                        tempCtx.beginPath();
                        tempCtx.moveTo(legendX + cornerRadius, legendY);
                        tempCtx.lineTo(legendX + legendWidth - cornerRadius, legendY);
                        tempCtx.quadraticCurveTo(legendX + legendWidth, legendY, legendX + legendWidth, legendY + cornerRadius);
                        tempCtx.lineTo(legendX + legendWidth, legendY + legendHeight - cornerRadius);
                        tempCtx.quadraticCurveTo(legendX + legendWidth, legendY + legendHeight, legendX + legendWidth - cornerRadius, legendY + legendHeight);
                        tempCtx.lineTo(legendX + cornerRadius, legendY + legendHeight);
                        tempCtx.quadraticCurveTo(legendX, legendY + legendHeight, legendX, legendY + legendHeight - cornerRadius);
                        tempCtx.lineTo(legendX, legendY + cornerRadius);
                        tempCtx.quadraticCurveTo(legendX, legendY, legendX + cornerRadius, legendY);
                        tempCtx.closePath();
                        tempCtx.fill();
                        tempCtx.stroke();
                        
                        // Draw legend title
                        tempCtx.fillStyle = '#374151';
                        tempCtx.font = 'bold 10px Arial';
                        tempCtx.textAlign = 'center';
                        tempCtx.fillText('Legend', legendX + legendWidth/2, legendY + 14);
                        
                        // Draw legend items
                        tempCtx.font = '9px Arial';
                        tempCtx.textAlign = 'left';
                        
                        for (let i = 0; i < legendItems.length; i++) {
                            const item = legendItems[i];
                            const itemY = legendY + 26 + (i * 16); // More compact spacing
                            
                            // Get the color indicator element
                            const colorDiv = item.querySelector('div');
                            const textSpan = item.querySelector('span');
                            
                            if (colorDiv && textSpan) {
                                const text = textSpan.textContent;
                                const bgColor = colorDiv.style.backgroundColor;
                                
                                // Parse color from style (handle different formats)
                                let color = '#000000';
                                if (bgColor) {
                                    if (bgColor.startsWith('rgb')) {
                                        // Convert rgb to hex if needed
                                        const matches = bgColor.match(/\d+/g);
                                        if (matches && matches.length >= 3) {
                                            const r = parseInt(matches[0]).toString(16).padStart(2, '0');
                                            const g = parseInt(matches[1]).toString(16).padStart(2, '0');
                                            const b = parseInt(matches[2]).toString(16).padStart(2, '0');
                                            color = `#${r}${g}${b}`;
                                        }
                                    } else if (bgColor.startsWith('#')) {
                                        color = bgColor;
                                    }
                                }
                                
                                // Special handling for logo (pattern)
                                if (text === 'Logo') {
                                    // Draw checkered pattern for logo (smaller)
                                    tempCtx.fillStyle = '#3b82f6';
                                    for (let x = 0; x < 8; x += 2) {
                                        for (let y = 0; y < 6; y += 2) {
                                            if ((x + y) % 4 === 0) {
                                                tempCtx.fillRect(legendX + 6 + x, itemY - 4 + y, 1, 1);
                                            }
                                        }
                                    }
                                } else {
                                    // Draw colored line for other items (smaller)
                                    tempCtx.strokeStyle = color;
                                    tempCtx.lineWidth = 1.5;
                                    tempCtx.setLineDash([2, 1]); // Smaller dashed line
                                    tempCtx.beginPath();
                                    tempCtx.moveTo(legendX + 6, itemY - 1);
                                    tempCtx.lineTo(legendX + 16, itemY - 1);
                                    tempCtx.stroke();
                                    tempCtx.setLineDash([]); // Reset dash
                                }
                                
                                // Draw text
                                tempCtx.fillStyle = '#374151';
                                tempCtx.fillText(text, legendX + 20, itemY);
                            }
                        }
                        
                        console.log('✅ Legend added to canvas');
                    } else {
                        console.log('ℹ️ No legend to add to canvas');
                    }
                    
                    // Return the combined image
                    resolve(tempCanvas.toDataURL('image/png'));
                };
                
                // Start the process by loading the canvas image
                canvasImage.src = canvas.toDataURL('image/png');
            });
        }
        
        // Generate Proposal button click handler
        document.getElementById('generateProposal').addEventListener('click', async function() {
            if (!currentImage) {
                alert('Please upload and position an image first before generating a proposal.');
                return;
            }
            
            // Get canvas image data including legend
            console.log('🖼️ Getting canvas image data with legend...');
            const imageDataURL = await getCanvasWithLegend();
            console.log('📊 Image data size:', Math.round(imageDataURL.length / 1024), 'KB');
            
            // Simple form data with just the image
            const formData = {
                building_name: 'Test Building',
                address: 'Test Address',
                imageData: imageDataURL
            };
            
            // Disable button and show loading state
            const btn = document.getElementById('generateProposal');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Generating Proposal...';
            
            try {
                console.log('🚀 Sending request to backend...');
                // Send request to backend
                const response = await fetch('/api/generate-proposal', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });
                
                console.log('📨 Response status:', response.status);
                
                if (response.ok) {
                    console.log('✅ Response OK, handling file download...');
                    // Handle file download
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    
                    // Extract filename from response headers or use default
                    const contentDisposition = response.headers.get('Content-Disposition');
                    let filename = 'proposal.pptx';
                    if (contentDisposition) {
                        const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                        if (filenameMatch) {
                            filename = filenameMatch[1];
                        }
                    }
                    console.log('📁 Filename:', filename);
                    a.download = filename;
                    
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    alert('Proposal generated successfully! Download should start automatically.');
                    
                } else {
                    const errorText = await response.text();
                    console.error('❌ Backend error:', errorText);
                    throw new Error(`Backend error: ${response.status} - ${errorText}`);
                }
                
            } catch (error) {
                console.error('❌ Error generating proposal:', error);
                alert(`Error generating proposal: ${error.message}`);
            } finally {
                // Re-enable button
                btn.disabled = false;
                btn.textContent = originalText;
            }
        });

        // Mobile touch optimization
        function preventDefaultTouch(e) {
            if (e.target.tagName === 'CANVAS') {
                e.preventDefault();
            }
        }
        
        // Keyboard event handling for delete key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (isDrawMode) {
                    const activeObject = canvas.getActiveObject();
                    if (activeObject && activeObject.type === 'line' && activeObject !== cropRect && activeObject !== currentImage) {
                        canvas.remove(activeObject);
                        canvas.discardActiveObject();
                        canvas.renderAll();
                        updateLegend(); // Update legend when object is deleted
                    }
                }
            }
        });

        // Initialize canvas on page load
        window.addEventListener('load', function() {
            initCanvas();
            
            // Prevent default touch behavior on canvas
            document.addEventListener('touchstart', preventDefaultTouch, { passive: false });
            document.addEventListener('touchmove', preventDefaultTouch, { passive: false });
            document.addEventListener('touchend', preventDefaultTouch, { passive: false });
            
            // Make canvas responsive
            function resizeCanvas() {
                const container = document.getElementById('canvasContainer');
                const canvasElement = document.getElementById('fabricCanvas');
                const containerWidth = container.offsetWidth - 4; // Account for border
                const scale = Math.min(1, containerWidth / CROP_WIDTH);
                
                if (canvas) {
                    if (scale < 1) {
                        // Scale both the visual display and the fabric canvas
                        canvas.setDimensions({
                            width: CROP_WIDTH * scale,
                            height: CROP_HEIGHT * scale
                        });
                        canvas.setZoom(scale);
                        container.style.height = (CROP_HEIGHT * scale + 4) + 'px';
                        
                        // Remove CSS transform since we're using fabric scaling
                        canvasElement.style.transform = 'none';
                    } else {
                        canvas.setDimensions({
                            width: CROP_WIDTH,
                            height: CROP_HEIGHT
                        });
                        canvas.setZoom(1);
                        container.style.height = CROP_HEIGHT + 'px';
                        canvasElement.style.transform = 'none';
                    }
                    
                    canvas.calcOffset();
                }
            }
            
            // Resize on load and window resize
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        });

        // Add some CSS for active tool styling
        const style = document.createElement('style');
        style.textContent = `
            .active-tool {
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                position: relative;
                z-index: 10;
            }
            .active-tool::after {
                content: '';
                position: absolute;
                inset: -2px;
                border-radius: inherit;
                background: linear-gradient(45deg, rgba(255,255,255,0.3), transparent);
                z-index: -1;
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>