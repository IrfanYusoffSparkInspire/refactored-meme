<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Image Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">Image Editor</h1>
        
        <!-- Upload Sections -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <!-- MSB Image Upload -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-4 text-center">MSB Image Upload</h3>
                <div class="flex items-center justify-center w-full">
                    <label for="msbImageInput" class="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100">
                        <div class="flex flex-col items-center justify-center pt-5 pb-6">
                            <svg class="w-8 h-8 mb-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                            </svg>
                            <p class="mb-2 text-sm text-gray-500">
                                <span class="font-semibold">Click to upload MSB</span> or drag and drop
                            </p>
                            <p class="text-xs text-gray-500">PNG, JPG or JPEG</p>
                            <p class="text-xs text-blue-600 mt-1">Dimensions: 9.05cm √ó 9.25cm</p>
                        </div>
                        <input id="msbImageInput" type="file" class="hidden" accept="image/*" />
                    </label>
                </div>
                <div id="msbImagePreview" class="mt-4 hidden">
                    <p class="text-sm text-gray-600 mb-2">Preview:</p>
                    <img id="msbPreviewImg" src="" alt="MSB Preview" class="w-full h-20 object-contain border rounded">
                    <button id="removeMsbImage" class="mt-2 px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">Remove</button>
                </div>
            </div>

            <!-- MCCB Image Upload -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-4 text-center">MCCB Image Upload</h3>
                <div class="flex items-center justify-center w-full">
                    <label for="mccbImageInput" class="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100">
                        <div class="flex flex-col items-center justify-center pt-5 pb-6">
                            <svg class="w-8 h-8 mb-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                            </svg>
                            <p class="mb-2 text-sm text-gray-500">
                                <span class="font-semibold">Click to upload MCCB</span> or drag and drop
                            </p>
                            <p class="text-xs text-gray-500">PNG, JPG or JPEG</p>
                            <p class="text-xs text-green-600 mt-1">Dimensions: 4.22cm √ó 4.57cm</p>
                        </div>
                        <input id="mccbImageInput" type="file" class="hidden" accept="image/*" />
                    </label>
                </div>
                <div id="mccbImagePreview" class="mt-4 hidden">
                    <p class="text-sm text-gray-600 mb-2">Preview:</p>
                    <img id="mccbPreviewImg" src="" alt="MCCB Preview" class="w-full h-20 object-contain border rounded">
                    <button id="removeMccbImage" class="mt-2 px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">Remove</button>
                </div>
            </div>
        </div>

        <!-- Image Selection for Editing -->
        <div id="imageSelectionPanel" class="bg-white rounded-lg shadow-md p-6 mb-6 hidden">
            <h3 class="text-lg font-semibold text-gray-800 mb-4 text-center">Select Image to Edit</h3>
            <div class="flex flex-col sm:flex-row justify-center gap-4">
                <button id="editMsbImage" class="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed">
                    Edit MSB Image
                    <span class="block text-sm opacity-75">(9.05cm √ó 9.25cm)</span>
                </button>
                <button id="editMccbImage" class="px-6 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 disabled:bg-gray-300 disabled:cursor-not-allowed">
                    Edit MCCB Image  
                    <span class="block text-sm opacity-75">(4.22cm √ó 4.57cm)</span>
                </button>
            </div>
            <div id="currentlyEditing" class="text-center mt-4 text-sm text-gray-600"></div>
        </div>

        <!-- Toolbar -->
        <div id="toolbar" class="bg-white rounded-lg shadow-md p-2 sm:p-4 mb-6 hidden">
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-4 gap-2">
                <h3 class="text-lg font-semibold text-gray-800">Tools</h3>
                <div class="flex flex-col sm:flex-row items-start sm:items-center gap-2 sm:space-x-4">
                    <label class="text-sm text-gray-600">Mode:</label>
                    <select id="editMode" class="px-3 py-1 border border-gray-300 rounded-md text-sm">
                        <option value="crop">Crop Mode</option>
                        <option value="draw">Draw Mode</option>
                    </select>
                </div>
            </div>
            
            <!-- Crop Controls -->
            <div id="cropControls" class="flex flex-col sm:flex-row items-start sm:items-center gap-2 sm:space-x-4 mb-4">
                <div class="flex items-center space-x-2">
                    <label class="text-sm text-gray-600">Zoom:</label>
                    <input id="zoomSlider" type="range" min="0.1" max="3" step="0.1" value="1" class="w-24">
                    <span id="zoomValue" class="text-sm text-gray-600">1x</span>
                </div>
                <button id="resetZoom" class="px-3 py-1 bg-gray-500 text-white rounded-md text-sm hover:bg-gray-600">Reset</button>
            </div>

            <!-- Drawing Controls -->
            <div id="drawControls" class="hidden">
                <div class="flex flex-wrap items-center gap-2 mb-4">
                    <label class="text-sm text-gray-600 w-full sm:w-auto">Drawing Tool:</label>
                    <button id="selectTool" class="px-3 py-2 bg-gray-400 text-white rounded-md text-sm hover:bg-gray-500 active-tool flex-1 sm:flex-none border-2 border-gray-600 shadow-lg">Select/Edit</button>
                    <button id="trayTool" class="px-3 py-2 bg-red-500 text-white rounded-md text-sm hover:bg-red-600 flex-1 sm:flex-none transition-all duration-200">Tray</button>
                    <button id="msTrunkingTool" class="px-3 py-2 bg-purple-500 text-white rounded-md text-sm hover:bg-purple-600 flex-1 sm:flex-none transition-all duration-200">MS Trunking</button>
                    <button id="hdgTrunkingTool" class="px-3 py-2 bg-green-600 text-white rounded-md text-sm hover:bg-green-700 flex-1 sm:flex-none transition-all duration-200">HDG Trunking</button>
                    <button id="giPipeTool" class="px-3 py-2 bg-orange-500 text-white rounded-md text-sm hover:bg-orange-600 flex-1 sm:flex-none transition-all duration-200">GI Pipe</button>
                    <button id="corrugatedPipeTool" class="px-3 py-2 bg-cyan-500 text-white rounded-md text-sm hover:bg-cyan-600 flex-1 sm:flex-none transition-all duration-200">Corrugated Pipe</button>
                    <button id="logoTool" class="px-3 py-2 bg-blue-600 text-white rounded-md text-sm hover:bg-blue-700 flex-1 sm:flex-none transition-all duration-200">Add Logo</button>
                    <button id="eraserTool" class="px-3 py-2 bg-yellow-500 text-white rounded-md text-sm hover:bg-yellow-600 flex-1 sm:flex-none transition-all duration-200">Eraser</button>
                    <button id="clearDrawing" class="px-3 py-2 bg-gray-500 text-white rounded-md text-sm hover:bg-gray-600 flex-1 sm:flex-none">Clear All</button>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 sm:space-x-4">
                <button id="generateProposal" class="px-4 sm:px-6 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm sm:text-base">Generate Proposal</button>
                <button id="resetCanvas" class="px-4 sm:px-6 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm sm:text-base">Reset</button>
            </div>
        </div>

        <!-- Canvas Container -->
        <div class="bg-white rounded-lg shadow-md p-2 sm:p-6">
            <div class="flex justify-center">
                <!-- MSB Canvas -->
                <div id="msbCanvasContainer" class="relative border-2 border-blue-300 rounded-lg overflow-hidden touch-none hidden" style="max-width: 100%; width: 342px; height: 350px; min-width: 280px;">
                    <canvas id="msbCanvas" width="342" height="350" style="max-width: 100%; height: auto; display: block; margin: 0 auto;"></canvas>
                    <div class="absolute top-2 left-2 bg-blue-500 text-white px-2 py-1 rounded text-xs font-semibold">MSB Canvas</div>
                    <!-- Legend Box for MSB -->
                    <div id="msbLegendBox" class="absolute bottom-2 right-2 bg-white border border-gray-300 rounded-lg shadow-lg p-1.5 text-xs hidden" style="min-width: 80px;">
                        <div class="font-medium text-gray-700 mb-0.5 text-center text-xs">Legend</div>
                        <div id="msbLegendContent"></div>
                    </div>
                </div>
                
                <!-- MCCB Canvas -->
                <div id="mccbCanvasContainer" class="relative border-2 border-green-300 rounded-lg overflow-hidden touch-none hidden" style="max-width: 100%; width: 160px; height: 173px; min-width: 160px;">
                    <canvas id="mccbCanvas" width="160" height="173" style="max-width: 100%; height: auto; display: block; margin: 0 auto;"></canvas>
                    <div class="absolute top-2 left-2 bg-green-500 text-white px-2 py-1 rounded text-xs font-semibold">MCCB Canvas</div>
                    <!-- Legend Box for MCCB -->
                    <div id="mccbLegendBox" class="absolute bottom-2 right-2 bg-white border border-gray-300 rounded-lg shadow-lg p-1.5 text-xs hidden" style="min-width: 80px;">
                        <div class="font-medium text-gray-700 mb-0.5 text-center text-xs">Legend</div>
                        <div id="mccbLegendContent"></div>
                    </div>
                </div>
                
                <!-- Default empty state -->
                <div id="emptyCanvasState" class="relative border-2 border-gray-300 border-dashed rounded-lg overflow-hidden touch-none flex items-center justify-center" style="width: 342px; height: 350px;">
                    <div class="text-center text-gray-500">
                        <svg class="w-16 h-16 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                        </svg>
                        <p class="text-sm font-medium">Upload and select an image to start editing</p>
                        <p class="text-xs mt-1">MSB (9.05√ó9.25cm) or MCCB (4.22√ó4.57cm)</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Image Gallery Selector (initially hidden) -->
        <div id="imageGallery" class="bg-white rounded-lg shadow-lg border-2 border-blue-300 p-6 mt-6 hidden relative z-50">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-gray-800 text-blue-600">üñºÔ∏è Select a Logo to Add</h3>
                <button id="closeGallery" class="text-gray-500 hover:text-red-500 text-2xl font-bold bg-gray-100 hover:bg-red-100 rounded-full w-8 h-8 flex items-center justify-center">&times;</button>
            </div>
            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4" id="galleryGrid">
                <!-- Images will be loaded here dynamically -->
            </div>
            <div class="mt-4 text-center">
                <p class="text-sm text-gray-600">Click on any logo above to add it to your image</p>
            </div>
        </div>

        <!-- Info Panel -->
        <div id="infoPanel" class="bg-white rounded-lg shadow-md p-4 mt-6 hidden">
            <h3 class="text-lg font-semibold text-gray-800 mb-2">Instructions</h3>
            <div id="cropInstructions" class="text-sm text-gray-600">
                <p><strong>Crop Mode:</strong></p>
                <ul class="list-disc list-inside mt-1">
                    <li>Use the zoom slider to scale the image</li>
                    <li>Drag the image to position it within the crop area</li>
                    <li>The final crop will be 600x400 pixels</li>
                </ul>
            </div>
            <div id="drawInstructions" class="hidden text-sm text-gray-600">
                <p><strong>Draw Mode:</strong></p>
                <ul class="list-disc list-inside mt-1">
                    <li><strong>Select/Edit:</strong> Default mode for selecting and editing existing objects safely</li>
                    <li><strong>Drawing Tools:</strong> Select Tray (red), MS Trunking (purple), HDG Trunking (green), GI Pipe (orange), or Corrugated Pipe (cyan) to draw straight dashed lines</li>
                    <li><strong>Add Logo:</strong> Click anywhere to place the company logo</li>
                    <li><strong>Eraser:</strong> Click on objects to delete them</li>
                    <li>Click on existing objects to select and edit them (move/resize)</li>
                    <li>Press Delete key to remove selected objects</li>
                    <li>Use "Clear All" to remove all drawings</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let msbCanvas = null;
        let mccbCanvas = null;
        let currentCanvas = null;
        let currentImage = null;
        let currentCropRect = null;
        let isDrawMode = false;
        let currentDrawTool = null;
        let originalImageData = null;
        let isEraserMode = false;
        let isLogoMode = false;
        let isSelectMode = true;
        
        // Image storage and canvas state
        let msbImageData = null;
        let mccbImageData = null;
        let currentEditingType = null; // 'msb' or 'mccb'
        
        // Canvas state storage
        let msbCanvasState = {
            image: null,
            cropRect: null,
            originalImageData: null
        };
        let mccbCanvasState = {
            image: null,
            cropRect: null,
            originalImageData: null
        };
        
        // Dimension constants
        const MSB_DIMENSIONS = { width: 342, height: 350 }; // 9.05cm √ó 9.25cm at 96 DPI
        const MCCB_DIMENSIONS = { width: 160, height: 173 }; // 4.22cm √ó 4.57cm at 96 DPI

        // Initialize separate canvases
        function initCanvases() {
            // Initialize MSB Canvas
            msbCanvas = new fabric.Canvas('msbCanvas', {
                width: MSB_DIMENSIONS.width,
                height: MSB_DIMENSIONS.height,
                backgroundColor: '#f8f9fa',
                enableRetinaScaling: false
            });

            // Initialize MCCB Canvas
            mccbCanvas = new fabric.Canvas('mccbCanvas', {
                width: MCCB_DIMENSIONS.width,
                height: MCCB_DIMENSIONS.height,
                backgroundColor: '#f8f9fa',
                enableRetinaScaling: false
            });

            // Add crop rectangles to both canvases
            msbCanvasState.cropRect = new fabric.Rect({
                left: 0,
                top: 0,
                width: MSB_DIMENSIONS.width,
                height: MSB_DIMENSIONS.height,
                fill: 'transparent',
                stroke: '#3b82f6',
                strokeWidth: 2,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false,
                excludeFromExport: true
            });
            msbCanvas.add(msbCanvasState.cropRect);

            mccbCanvasState.cropRect = new fabric.Rect({
                left: 0,
                top: 0,
                width: MCCB_DIMENSIONS.width,
                height: MCCB_DIMENSIONS.height,
                fill: 'transparent',
                stroke: '#3b82f6',
                strokeWidth: 2,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false,
                excludeFromExport: true
            });
            mccbCanvas.add(mccbCanvasState.cropRect);

            // Add event listeners to both canvases
            setupCanvasEventListeners(msbCanvas);
            setupCanvasEventListeners(mccbCanvas);
        }

        // Setup event listeners for a canvas
        function setupCanvasEventListeners(canvas) {
            // Mouse and touch events
            canvas.on('mouse:down', handleMouseDown);
            canvas.on('mouse:move', handleMouseMove);
            canvas.on('mouse:up', handleMouseUp);
            
            // Touch events for mobile
            canvas.on('touch:gesture', function(e) {
                e.e.preventDefault();
                e.e.stopPropagation();
            });
            
            canvas.on('touch:drag', function(e) {
                if (isDrawMode) {
                    handleMouseMove(e);
                }
            });
            canvas.on('path:created', handlePathCreated);
        }

        // Handle MSB image upload
        document.getElementById('msbImageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    msbImageData = event.target.result;
                    showImagePreview('msb', event.target.result);
                    updateImageSelectionPanel();
                };
                reader.readAsDataURL(file);
            }
        });

        // Handle MCCB image upload
        document.getElementById('mccbImageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    mccbImageData = event.target.result;
                    showImagePreview('mccb', event.target.result);
                    updateImageSelectionPanel();
                };
                reader.readAsDataURL(file);
            }
        });

        // Show image preview
        function showImagePreview(type, imageSrc) {
            const previewContainer = document.getElementById(`${type}ImagePreview`);
            const previewImg = document.getElementById(`${type}PreviewImg`);
            
            previewImg.src = imageSrc;
            previewContainer.classList.remove('hidden');
        }

        // Update image selection panel visibility
        function updateImageSelectionPanel() {
            const panel = document.getElementById('imageSelectionPanel');
            const msbButton = document.getElementById('editMsbImage');
            const mccbButton = document.getElementById('editMccbImage');
            
            if (msbImageData || mccbImageData) {
                panel.classList.remove('hidden');
                msbButton.disabled = !msbImageData;
                mccbButton.disabled = !mccbImageData;
            } else {
                panel.classList.add('hidden');
            }
        }

        // Switch between canvas types
        function switchToImageType(type) {
            currentEditingType = type;
            
            // Hide empty state
            document.getElementById('emptyCanvasState').classList.add('hidden');
            
            if (type === 'msb') {
                // Show MSB canvas, hide MCCB canvas
                document.getElementById('msbCanvasContainer').classList.remove('hidden');
                document.getElementById('mccbCanvasContainer').classList.add('hidden');
                
                // Set current canvas reference
                currentCanvas = msbCanvas;
                currentImage = msbCanvasState.image;
                currentCropRect = msbCanvasState.cropRect;
                originalImageData = msbCanvasState.originalImageData;
                
                // Load image if not already loaded
                if (msbImageData && !msbCanvasState.image) {
                    loadImageToCanvas(type, msbImageData);
                }
                
                document.getElementById('currentlyEditing').textContent = 'Currently editing: MSB Image (9.05cm √ó 9.25cm)';
                
            } else if (type === 'mccb') {
                // Show MCCB canvas, hide MSB canvas
                document.getElementById('mccbCanvasContainer').classList.remove('hidden');
                document.getElementById('msbCanvasContainer').classList.add('hidden');
                
                // Set current canvas reference
                currentCanvas = mccbCanvas;
                currentImage = mccbCanvasState.image;
                currentCropRect = mccbCanvasState.cropRect;
                originalImageData = mccbCanvasState.originalImageData;
                
                // Load image if not already loaded
                if (mccbImageData && !mccbCanvasState.image) {
                    loadImageToCanvas(type, mccbImageData);
                }
                
                document.getElementById('currentlyEditing').textContent = 'Currently editing: MCCB Image (4.22cm √ó 4.57cm)';
            }
            
            // Show toolbar and info panel
            document.getElementById('toolbar').classList.remove('hidden');
            document.getElementById('infoPanel').classList.remove('hidden');
            
            // Update zoom slider if we have an image
            if (currentImage) {
                document.getElementById('zoomSlider').value = currentImage.scaleX;
                document.getElementById('zoomValue').textContent = currentImage.scaleX.toFixed(1) + 'x';
            }
            
            // Recalculate canvas offset
            setTimeout(() => {
                if (currentCanvas) {
                    currentCanvas.calcOffset();
                }
            }, 100);
        }

        // Load image onto specific canvas
        function loadImageToCanvas(canvasType, imageSrc) {
            if (!imageSrc || !canvasType) return;
            
            const targetCanvas = canvasType === 'msb' ? msbCanvas : mccbCanvas;
            const canvasState = canvasType === 'msb' ? msbCanvasState : mccbCanvasState;
            const dimensions = canvasType === 'msb' ? MSB_DIMENSIONS : MCCB_DIMENSIONS;
            
            fabric.Image.fromURL(imageSrc, function(img) {
                // Store original image data
                canvasState.originalImageData = imageSrc;
                
                // Remove existing image if any
                if (canvasState.image) {
                    targetCanvas.remove(canvasState.image);
                }

                // Scale image to fit within crop area initially
                const scaleX = dimensions.width / img.width;
                const scaleY = dimensions.height / img.height;
                const scale = Math.min(scaleX, scaleY);
                
                img.set({
                    left: dimensions.width / 2,
                    top: dimensions.height / 2,
                    originX: 'center',
                    originY: 'center',
                    scaleX: scale,
                    scaleY: scale
                });

                // Store image reference
                canvasState.image = img;
                targetCanvas.add(img);
                targetCanvas.sendToBack(img);
                targetCanvas.bringToFront(canvasState.cropRect);
                targetCanvas.renderAll();

                // Update current references if this is the active canvas
                if (currentEditingType === canvasType) {
                    currentImage = img;
                    originalImageData = imageSrc;
                    
                    // Update zoom slider
                    document.getElementById('zoomSlider').value = scale;
                    document.getElementById('zoomValue').textContent = scale.toFixed(1) + 'x';
                }
                
                // Recalculate canvas offset
                setTimeout(() => {
                    targetCanvas.calcOffset();
                }, 100);
            });
        }

        // Legacy function kept for compatibility
        function loadImage(imageSrc) {
            // This is now just an alias that defaults to MSB
            msbImageData = imageSrc;
            showImagePreview('msb', imageSrc);
            updateImageSelectionPanel();
            switchToImageType('msb');
        }

        // Image selection buttons
        document.getElementById('editMsbImage').addEventListener('click', function() {
            switchToImageType('msb');
        });

        document.getElementById('editMccbImage').addEventListener('click', function() {
            switchToImageType('mccb');
        });

        // Remove image buttons
        document.getElementById('removeMsbImage').addEventListener('click', function() {
            msbImageData = null;
            document.getElementById('msbImagePreview').classList.add('hidden');
            document.getElementById('msbImageInput').value = '';
            updateImageSelectionPanel();
            
            // Clear MSB canvas
            clearSpecificCanvas('msb');
            
            // If currently editing MSB, hide the editor
            if (currentEditingType === 'msb') {
                showEmptyState();
            }
        });

        document.getElementById('removeMccbImage').addEventListener('click', function() {
            mccbImageData = null;
            document.getElementById('mccbImagePreview').classList.add('hidden');
            document.getElementById('mccbImageInput').value = '';
            updateImageSelectionPanel();
            
            // Clear MCCB canvas
            clearSpecificCanvas('mccb');
            
            // If currently editing MCCB, hide the editor
            if (currentEditingType === 'mccb') {
                showEmptyState();
            }
        });

        function clearSpecificCanvas(canvasType) {
            const targetCanvas = canvasType === 'msb' ? msbCanvas : mccbCanvas;
            const canvasState = canvasType === 'msb' ? msbCanvasState : mccbCanvasState;
            const dimensions = canvasType === 'msb' ? MSB_DIMENSIONS : MCCB_DIMENSIONS;
            
            if (targetCanvas) {
                // Clear all objects except keep a fresh crop rectangle
                targetCanvas.clear();
                
                // Re-add crop rectangle
                canvasState.cropRect = new fabric.Rect({
                    left: 0,
                    top: 0,
                    width: dimensions.width,
                    height: dimensions.height,
                    fill: 'transparent',
                    stroke: '#3b82f6',
                    strokeWidth: 2,
                    strokeDashArray: [5, 5],
                    selectable: false,
                    evented: false,
                    excludeFromExport: true
                });
                targetCanvas.add(canvasState.cropRect);
                targetCanvas.setBackgroundColor('#f8f9fa', targetCanvas.renderAll.bind(targetCanvas));
                
                // Clear state
                canvasState.image = null;
                canvasState.originalImageData = null;
            }
        }

        function showEmptyState() {
            // Hide all canvases
            document.getElementById('msbCanvasContainer').classList.add('hidden');
            document.getElementById('mccbCanvasContainer').classList.add('hidden');
            
            // Show empty state
            document.getElementById('emptyCanvasState').classList.remove('hidden');
            
            // Hide toolbar and info panel
            document.getElementById('toolbar').classList.add('hidden');
            document.getElementById('infoPanel').classList.add('hidden');
            document.getElementById('currentlyEditing').textContent = '';
            
            // Clear current references
            currentCanvas = null;
            currentImage = null;
            currentCropRect = null;
            originalImageData = null;
            currentEditingType = null;
        }

        // Mode switching
        document.getElementById('editMode').addEventListener('change', function(e) {
            const mode = e.target.value;
            isDrawMode = mode === 'draw';
            
            if (isDrawMode) {
                document.getElementById('cropControls').classList.add('hidden');
                document.getElementById('drawControls').classList.remove('hidden');
                document.getElementById('cropInstructions').classList.add('hidden');
                document.getElementById('drawInstructions').classList.remove('hidden');
                
                // Disable image selection and movement
                if (currentImage) {
                    currentImage.set({
                        selectable: false,
                        evented: false
                    });
                }
                
                // Enable custom drawing mode for straight lines on current canvas
                if (currentCanvas) {
                    currentCanvas.isDrawingMode = false; // Disable fabric.js freeform drawing
                    currentCanvas.selection = true; // Allow selection of drawn lines
                }
            } else {
                document.getElementById('cropControls').classList.remove('hidden');
                document.getElementById('drawControls').classList.add('hidden');
                document.getElementById('cropInstructions').classList.remove('hidden');
                document.getElementById('drawInstructions').classList.add('hidden');
                
                // Enable image selection and movement
                if (currentImage) {
                    currentImage.set({
                        selectable: true,
                        evented: true
                    });
                }
                
                canvas.isDrawingMode = false;
                canvas.selection = true;
            }
            canvas.renderAll();
        });

        // Zoom controls
        document.getElementById('zoomSlider').addEventListener('input', function(e) {
            const zoom = parseFloat(e.target.value);
            if (currentImage && currentCanvas) {
                currentImage.set({
                    scaleX: zoom,
                    scaleY: zoom
                });
                currentCanvas.renderAll();
                document.getElementById('zoomValue').textContent = zoom.toFixed(1) + 'x';
            }
        });

        document.getElementById('resetZoom').addEventListener('click', function() {
            if (currentImage && currentCanvas) {
                const dimensions = currentEditingType === 'msb' ? MSB_DIMENSIONS : MCCB_DIMENSIONS;
                const scaleX = dimensions.width / (currentImage.width * currentImage.scaleX);
                const scaleY = dimensions.height / (currentImage.height * currentImage.scaleY);
                const scale = Math.min(scaleX, scaleY);
                
                currentImage.set({
                    scaleX: scale,
                    scaleY: scale,
                    left: dimensions.width / 2,
                    top: dimensions.height / 2
                });
                currentCanvas.renderAll();
                
                document.getElementById('zoomSlider').value = scale;
                document.getElementById('zoomValue').textContent = scale.toFixed(1) + 'x';
            }
        });

        // Drawing tool selection
        document.getElementById('selectTool').addEventListener('click', function() {
            currentDrawTool = null;
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = true;
            updateDrawToolUI();
        });

        document.getElementById('trayTool').addEventListener('click', function() {
            currentDrawTool = 'tray';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('msTrunkingTool').addEventListener('click', function() {
            currentDrawTool = 'msTrunking';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('hdgTrunkingTool').addEventListener('click', function() {
            currentDrawTool = 'hdgTrunking';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('giPipeTool').addEventListener('click', function() {
            currentDrawTool = 'giPipe';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('corrugatedPipeTool').addEventListener('click', function() {
            currentDrawTool = 'corrugatedPipe';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('logoTool').addEventListener('click', function() {
            isLogoMode = true;
            isEraserMode = false;
            isSelectMode = false;
            currentDrawTool = null;
            updateDrawToolUI();
        });

        document.getElementById('eraserTool').addEventListener('click', function() {
            isEraserMode = true;
            isLogoMode = false;
            isSelectMode = false;
            currentDrawTool = null;
            canvas.isDrawingMode = false; // Disable drawing mode for eraser
            updateDrawToolUI();
        });

        function getToolColor(tool) {
            switch(tool) {
                case 'tray': return '#ef4444'; // red
                case 'msTrunking': return '#8b5cf6'; // purple
                case 'hdgTrunking': return '#059669'; // green
                case 'giPipe': return '#f97316'; // orange
                case 'corrugatedPipe': return '#06b6d4'; // cyan
                default: return '#ef4444';
            }
        }

        function getToolName(tool) {
            switch(tool) {
                case 'tray': return 'Tray';
                case 'msTrunking': return 'MS Trunking';
                case 'hdgTrunking': return 'HDG Trunking';
                case 'giPipe': return 'GI Pipe';
                case 'corrugatedPipe': return 'Corrugated Pipe';
                default: return 'Unknown';
            }
        }

        function updateLegend() {
            if (!currentCanvas || !currentEditingType) return;
            
            const legendBox = document.getElementById(`${currentEditingType}LegendBox`);
            const legendContent = document.getElementById(`${currentEditingType}LegendContent`);
            
            if (!legendBox || !legendContent) return;
            
            // Get all objects except background image and crop rectangle
            const objects = currentCanvas.getObjects();
            const drawnObjects = objects.filter(obj => 
                obj !== currentCropRect && obj !== currentImage && 
                (obj.type === 'line' || obj.type === 'image')
            );
            
            if (drawnObjects.length === 0) {
                legendBox.classList.add('hidden');
                return;
            }
            
            // Group objects by type/color
            const legendItems = new Map();
            
            drawnObjects.forEach(obj => {
                if (obj.type === 'line') {
                    const color = obj.stroke;
                    let toolName = 'Unknown';
                    
                    // Match color to tool name
                    if (color === '#ef4444') toolName = 'Tray';
                    else if (color === '#8b5cf6') toolName = 'MS Trunking';
                    else if (color === '#059669') toolName = 'HDG Trunking';
                    else if (color === '#f97316') toolName = 'GI Pipe';
                    else if (color === '#06b6d4') toolName = 'Corrugated Pipe';
                    
                    if (!legendItems.has(toolName)) {
                        legendItems.set(toolName, { color, count: 0 });
                    }
                    legendItems.get(toolName).count++;
                } else if (obj.type === 'image' && obj !== currentImage) {
                    // This is a logo - skip adding to legend
                    // Logos don't need to be shown in legend
                }
            });
            
            // Build legend HTML
            let legendHTML = '';
            legendItems.forEach((item, name) => {
                // Only show line types, skip logos
                legendHTML += `
                    <div class="flex items-center mb-0.5">
                        <div class="w-2.5 h-0.5 mr-1.5 border-dashed" style="background-color: ${item.color}; border: 1px dashed ${item.color};"></div>
                        <span class="text-gray-700 text-xs">${name}</span>
                    </div>`;
            });
            
            legendContent.innerHTML = legendHTML;
            legendBox.classList.remove('hidden');
        }

        function updateDrawToolUI() {
            // Remove active styling from all tools
            document.querySelectorAll('#selectTool, #trayTool, #msTrunkingTool, #hdgTrunkingTool, #giPipeTool, #corrugatedPipeTool, #logoTool, #eraserTool').forEach(btn => {
                btn.classList.remove('active-tool', 'border-2', 'shadow-lg');
                btn.classList.add('transition-all', 'duration-200');
            });
            
            if (isSelectMode) {
                document.getElementById('selectTool').classList.add('active-tool', 'border-2', 'border-gray-600', 'shadow-lg');
                if (currentCanvas) {
                    currentCanvas.isDrawingMode = false;
                    currentCanvas.defaultCursor = 'default';
                }
            } else if (isEraserMode) {
                document.getElementById('eraserTool').classList.add('active-tool', 'border-2', 'border-yellow-300', 'shadow-lg');
                if (currentCanvas) {
                    currentCanvas.isDrawingMode = false;
                    currentCanvas.defaultCursor = 'crosshair';
                }
            } else if (isLogoMode) {
                document.getElementById('logoTool').classList.add('active-tool', 'border-2', 'border-blue-300', 'shadow-lg');
                if (currentCanvas) {
                    currentCanvas.isDrawingMode = false;
                    currentCanvas.defaultCursor = 'crosshair';
                }
            } else if (currentDrawTool) {
                const toolButton = document.getElementById(currentDrawTool + 'Tool');
                if (toolButton) {
                    const borderColor = currentDrawTool === 'tray' ? 'border-red-300' : 
                                      currentDrawTool === 'msTrunking' ? 'border-purple-300' : 
                                      currentDrawTool === 'hdgTrunking' ? 'border-green-300' :
                                      currentDrawTool === 'giPipe' ? 'border-orange-300' :
                                      currentDrawTool === 'corrugatedPipe' ? 'border-cyan-300' :
                                      'border-gray-300';
                    toolButton.classList.add('active-tool', 'border-2', borderColor, 'shadow-lg');
                }
                if (currentCanvas) {
                    currentCanvas.isDrawingMode = false; // We handle drawing manually for straight lines
                    currentCanvas.defaultCursor = 'crosshair';
                }
            }
        }

        // Drawing functionality
        let isDrawing = false;
        let startPoint = null;
        let currentLine = null;

        function handleMouseDown(e) {
            if (!isDrawMode || !currentCanvas) return;
            
            const pointer = currentCanvas.getPointer(e.e);
            
            if (isSelectMode) {
                // Select mode - only allow selecting existing objects
                const target = currentCanvas.findTarget(e.e, false);
                if (target && target !== currentCropRect && target !== currentImage) {
                    currentCanvas.setActiveObject(target);
                    currentCanvas.renderAll();
                } else {
                    currentCanvas.discardActiveObject();
                    currentCanvas.renderAll();
                }
                return;
            }
            
            if (isEraserMode) {
                // Eraser mode - find and remove clicked object
                const target = currentCanvas.findTarget(e.e, false);
                if (target && (target.type === 'line' || target.type === 'image') && target !== currentCropRect && target !== currentImage) {
                    currentCanvas.remove(target);
                    currentCanvas.renderAll();
                    updateLegend(); // Update legend when object is removed
                }
                return;
            }
            
            if (isLogoMode) {
                // Logo mode - place logo at click position
                placeLogo(pointer.x, pointer.y);
                return;
            }
            
            // Drawing mode - check if clicking on existing object first
            const target = currentCanvas.findTarget(e.e, false);
            if (target && target !== currentCropRect && target !== currentImage) {
                currentCanvas.setActiveObject(target);
                currentCanvas.renderAll();
                return;
            }
            
            // Start drawing new line only if we have a drawing tool selected
            if (currentDrawTool) {
                currentCanvas.discardActiveObject();
                isDrawing = true;
                startPoint = { x: pointer.x, y: pointer.y };
                
                // Create temporary line for preview
                currentLine = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
                    stroke: getToolColor(currentDrawTool),
                    strokeWidth: 9,
                    strokeDashArray: [8, 4],
                    selectable: false,
                    evented: false,
                    opacity: 0.7
                });
                currentCanvas.add(currentLine);
            }
        }

        function placeLogo(x, y) {
            // Try to load from file first
            fabric.Image.fromURL('./Timelogo.png', function(logoImg) {
                if (logoImg && logoImg.width > 0) {
                    addLogoToCanvas(logoImg, x, y);
                } else {
                    console.warn('Could not load logo from ./Timelogo.png, trying different approach...');
                    // Fallback: create a temporary file input to load logo
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*';
                    fileInput.style.display = 'none';
                    
                    fileInput.onchange = function(e) {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = function(event) {
                                fabric.Image.fromURL(event.target.result, function(logoImg) {
                                    addLogoToCanvas(logoImg, x, y);
                                });
                            };
                            reader.readAsDataURL(file);
                        }
                        document.body.removeChild(fileInput);
                    };
                    
                    document.body.appendChild(fileInput);
                    fileInput.click();
                }
            });
        }
        
        function addLogoToCanvas(logoImg, x, y) {
            if (!currentCanvas) return;
            
            // Scale the logo to a reasonable size (adjust as needed)
            const maxSize = 80; // Maximum width/height in pixels
            const scale = Math.min(maxSize / logoImg.width, maxSize / logoImg.height);
            
            logoImg.set({
                left: x,
                top: y,
                originX: 'center',
                originY: 'center',
                scaleX: scale,
                scaleY: scale,
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                cornerColor: '#fff',
                cornerStrokeColor: '#2563eb',
                borderColor: '#2563eb',
                cornerSize: 8
            });
            
            currentCanvas.add(logoImg);
            currentCanvas.bringToFront(logoImg);
            currentCanvas.bringToFront(currentCropRect);
            currentCanvas.setActiveObject(logoImg);
            currentCanvas.renderAll();
            updateLegend(); // Update legend when logo is added
        }

        function handleMouseMove(e) {
            if (!isDrawMode || !isDrawing || isEraserMode || isLogoMode || isSelectMode || !currentLine || !currentCanvas) return;
            
            const pointer = currentCanvas.getPointer(e.e);
            
            // Update preview line
            currentLine.set({
                x2: pointer.x,
                y2: pointer.y
            });
            currentCanvas.renderAll();
        }

        function handleMouseUp(e) {
            if (!isDrawMode || !isDrawing || isEraserMode || isLogoMode || isSelectMode || !currentCanvas) return;
            
            const pointer = currentCanvas.getPointer(e.e);
            isDrawing = false;
            
            if (currentLine && startPoint) {
                // Calculate minimum line length
                const distance = Math.sqrt(
                    Math.pow(pointer.x - startPoint.x, 2) + 
                    Math.pow(pointer.y - startPoint.y, 2)
                );
                
                // Remove preview line
                currentCanvas.remove(currentLine);
                
                if (distance > 10) { // Minimum line length
                    // Create final dashed line
                    const toolColor = getToolColor(currentDrawTool);
                    const finalLine = new fabric.Line([startPoint.x, startPoint.y, pointer.x, pointer.y], {
                        stroke: toolColor,
                        strokeWidth: 9,
                        strokeDashArray: [8, 4],
                        selectable: true,
                        evented: true,
                        hasControls: true,
                        hasBorders: true,
                        cornerColor: '#fff',
                        cornerStrokeColor: toolColor,
                        borderColor: toolColor,
                        cornerSize: 8
                    });
                    
                    currentCanvas.add(finalLine);
                    currentCanvas.bringToFront(finalLine);
                    currentCanvas.bringToFront(currentCropRect);
                    updateLegend(); // Update legend when line is added
                }
                
                currentCanvas.renderAll();
            }
            
            currentLine = null;
            startPoint = null;
        }

        function handlePathCreated(e) {
            // No longer needed since we're creating straight lines manually
        }

        // Clear drawing
        document.getElementById('clearDrawing').addEventListener('click', function() {
            if (!currentCanvas) return;
            
            const objects = currentCanvas.getObjects();
            const toRemove = objects.filter(obj => 
                (obj.type === 'line' || obj.type === 'path' || obj.type === 'Path') && obj !== currentCropRect && obj !== currentImage
            );
            toRemove.forEach(obj => currentCanvas.remove(obj));
            currentCanvas.renderAll();
            updateLegend(); // Update legend when all objects are cleared
        });


        // Reset canvas
        document.getElementById('resetCanvas').addEventListener('click', function() {
            // Clear all image data
            msbImageData = null;
            mccbImageData = null;
            
            // Clear both canvases completely
            clearSpecificCanvas('msb');
            clearSpecificCanvas('mccb');
            
            // Show empty state
            showEmptyState();
            
            // Hide all UI elements
            document.getElementById('imageSelectionPanel').classList.add('hidden');
            document.getElementById('msbImagePreview').classList.add('hidden');
            document.getElementById('mccbImagePreview').classList.add('hidden');
            document.getElementById('msbLegendBox').classList.add('hidden');
            document.getElementById('mccbLegendBox').classList.add('hidden');
            
            // Reset form inputs
            document.getElementById('msbImageInput').value = '';
            document.getElementById('mccbImageInput').value = '';
        });
        
        // Available images in the images folder
        const availableImages = [
            { name: 'DB', filename: 'DB.png', displayName: 'Distribution Board' },
            { name: 'ELR', filename: 'ELR.png', displayName: 'Earth Leakage Relay' },
            { name: 'Isolator', filename: 'Isolator.png', displayName: 'Isolator' },
            { name: 'KWH_METER', filename: 'KWH_METER.png', displayName: 'KWH Meter' },
            { name: 'Timelogo', filename: 'Timelogo.png', displayName: 'Time Logo' },
            { name: 'double_pedestal', filename: 'double_pedestal.png', displayName: 'Double Pedestal' },
            { name: 'wheel_stopper', filename: 'wheel_stopper.png', displayName: 'Wheel Stopper' }
        ];
        
        // Show image gallery
        function showImageGallery() {
            const gallery = document.getElementById('imageGallery');
            const galleryGrid = document.getElementById('galleryGrid');
            
            if (!gallery || !galleryGrid) {
                alert('Error: Gallery elements not found. Please refresh the page.');
                return;
            }
            
            // Clear existing content
            galleryGrid.innerHTML = '';
            
            // Add each image to the gallery
            availableImages.forEach((imageInfo) => {
                const imageCard = document.createElement('div');
                imageCard.className = 'border border-gray-300 rounded-lg p-2 hover:border-blue-500 hover:shadow-md cursor-pointer transition-all duration-200';
                imageCard.innerHTML = `
                    <img src="images/${imageInfo.filename}" alt="${imageInfo.displayName}" class="w-full h-20 object-contain mb-2 rounded">
                    <p class="text-xs text-gray-700 text-center truncate">${imageInfo.displayName}</p>
                `;
                
                imageCard.addEventListener('click', () => {
                    selectImage(imageInfo);
                });
                
                galleryGrid.appendChild(imageCard);
            });
            
            // Show the gallery
            gallery.classList.remove('hidden');
            gallery.style.display = 'block';
            gallery.style.visibility = 'visible';
            
            // Scroll to gallery
            setTimeout(() => {
                gallery.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }
        
        // Select and add image to canvas
        function selectImage(imageInfo) {
            if (!currentCanvas) {
                alert('Please select a canvas first before adding logos.');
                return;
            }
            
            const imagePath = `images/${imageInfo.filename}`;
            
            fabric.Image.fromURL(imagePath, function(logoImg) {
                // Add logo to center of current canvas
                const centerX = currentCanvas.width / 2;
                const centerY = currentCanvas.height / 2;
                addLogoToCanvas(logoImg, centerX, centerY);
            });
            
            // Hide the gallery
            document.getElementById('imageGallery').classList.add('hidden');
        }
        
        // Add logo to canvas function
        function addLogoToCanvas(logoImg, x, y) {
            // Scale the logo to a reasonable size
            const maxSize = 60; // Maximum width/height in pixels
            const scale = Math.min(maxSize / logoImg.width, maxSize / logoImg.height);
            
            logoImg.set({
                left: x,
                top: y,
                originX: 'center',
                originY: 'center',
                scaleX: scale,
                scaleY: scale,
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                cornerColor: '#fff',
                cornerStrokeColor: '#2563eb',
                borderColor: '#2563eb',
                cornerSize: 6
            });
            
            canvas.add(logoImg);
            canvas.bringToFront(logoImg);
            canvas.bringToFront(cropRect);
            canvas.setActiveObject(logoImg);
            canvas.renderAll();
            updateLegend(); // Update legend when logo is added
        }
        
        // Function to combine specific canvas with legend overlay
        async function getCanvasWithLegend(canvasType = null) {
            // If no specific canvas type provided, use current canvas
            const targetCanvasType = canvasType || currentEditingType;
            const targetCanvas = targetCanvasType === 'msb' ? msbCanvas : mccbCanvas;
            
            if (!targetCanvas || !targetCanvasType) {
                return null;
            }
            
            return new Promise((resolve) => {
                // Create a temporary canvas to combine canvas + legend
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Set same dimensions as target canvas
                tempCanvas.width = targetCanvas.width;
                tempCanvas.height = targetCanvas.height;
                
                // First, draw the original canvas content
                const canvasImage = new Image();
                canvasImage.onload = function() {
                    tempCtx.drawImage(canvasImage, 0, 0);
                    
                    // Check if legend is visible for target canvas type
                    const legendBox = document.getElementById(`${targetCanvasType}LegendBox`);
                    if (!legendBox.classList.contains('hidden')) {
                        console.log(`üìã Adding legend to ${targetCanvasType.toUpperCase()} canvas image...`);
                        
                        // Get legend content and styling
                        const legendContent = document.getElementById(`${targetCanvasType}LegendContent`);
                        const legendItems = legendContent.children;
                        
                        // Position for legend (bottom right with padding) - more compact
                        const legendWidth = 85; // Reduced from 110
                        const legendHeight = legendItems.length * 18 + 22; // Reduced spacing
                        const legendX = tempCanvas.width - legendWidth - 8; // 8px from right
                        const legendY = tempCanvas.height - legendHeight - 8; // 8px from bottom
                        
                        // Draw legend background (white rounded box with border)
                        tempCtx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        tempCtx.strokeStyle = '#d1d5db';
                        tempCtx.lineWidth = 1;
                        
                        // Draw rounded rectangle
                        const cornerRadius = 6;
                        tempCtx.beginPath();
                        tempCtx.moveTo(legendX + cornerRadius, legendY);
                        tempCtx.lineTo(legendX + legendWidth - cornerRadius, legendY);
                        tempCtx.quadraticCurveTo(legendX + legendWidth, legendY, legendX + legendWidth, legendY + cornerRadius);
                        tempCtx.lineTo(legendX + legendWidth, legendY + legendHeight - cornerRadius);
                        tempCtx.quadraticCurveTo(legendX + legendWidth, legendY + legendHeight, legendX + legendWidth - cornerRadius, legendY + legendHeight);
                        tempCtx.lineTo(legendX + cornerRadius, legendY + legendHeight);
                        tempCtx.quadraticCurveTo(legendX, legendY + legendHeight, legendX, legendY + legendHeight - cornerRadius);
                        tempCtx.lineTo(legendX, legendY + cornerRadius);
                        tempCtx.quadraticCurveTo(legendX, legendY, legendX + cornerRadius, legendY);
                        tempCtx.closePath();
                        tempCtx.fill();
                        tempCtx.stroke();
                        
                        // Draw legend title
                        tempCtx.fillStyle = '#374151';
                        tempCtx.font = 'bold 10px Arial';
                        tempCtx.textAlign = 'center';
                        tempCtx.fillText('Legend', legendX + legendWidth/2, legendY + 14);
                        
                        // Draw legend items
                        tempCtx.font = '9px Arial';
                        tempCtx.textAlign = 'left';
                        
                        for (let i = 0; i < legendItems.length; i++) {
                            const item = legendItems[i];
                            const itemY = legendY + 26 + (i * 16); // More compact spacing
                            
                            // Get the color indicator element
                            const colorDiv = item.querySelector('div');
                            const textSpan = item.querySelector('span');
                            
                            if (colorDiv && textSpan) {
                                const text = textSpan.textContent;
                                const bgColor = colorDiv.style.backgroundColor;
                                
                                // Parse color from style (handle different formats)
                                let color = '#000000';
                                if (bgColor) {
                                    if (bgColor.startsWith('rgb')) {
                                        // Convert rgb to hex if needed
                                        const matches = bgColor.match(/\d+/g);
                                        if (matches && matches.length >= 3) {
                                            const r = parseInt(matches[0]).toString(16).padStart(2, '0');
                                            const g = parseInt(matches[1]).toString(16).padStart(2, '0');
                                            const b = parseInt(matches[2]).toString(16).padStart(2, '0');
                                            color = `#${r}${g}${b}`;
                                        }
                                    } else if (bgColor.startsWith('#')) {
                                        color = bgColor;
                                    }
                                }
                                
                                // Draw colored line for all items (logos are excluded from legend)
                                tempCtx.strokeStyle = color;
                                tempCtx.lineWidth = 1.5;
                                tempCtx.setLineDash([2, 1]); // Smaller dashed line
                                tempCtx.beginPath();
                                tempCtx.moveTo(legendX + 6, itemY - 1);
                                tempCtx.lineTo(legendX + 16, itemY - 1);
                                tempCtx.stroke();
                                tempCtx.setLineDash([]); // Reset dash
                                
                                // Draw text
                                tempCtx.fillStyle = '#374151';
                                tempCtx.fillText(text, legendX + 20, itemY);
                            }
                        }
                        
                        console.log('‚úÖ Legend added to canvas');
                    } else {
                        console.log('‚ÑπÔ∏è No legend to add to canvas');
                    }
                    
                    // Return the combined image
                    resolve(tempCanvas.toDataURL('image/png'));
                };
                
                // Start the process by loading the canvas image
                canvasImage.src = targetCanvas.toDataURL('image/png');
            });
        }
        
        // Generate Proposal button click handler
        document.getElementById('generateProposal').addEventListener('click', async function() {
            if (!msbImageData && !mccbImageData) {
                alert('Please upload at least one image (MSB or MCCB) before generating a proposal.');
                return;
            }
            
            // Prepare form data object
            const formData = {
                building_name: 'Test Building',
                address: 'Test Address'
            };
            
            // Get MSB image data if available
            if (msbImageData) {
                console.log('üñºÔ∏è Processing MSB image data...');
                
                // Check if MSB canvas has any content (image loaded)
                if (msbCanvasState.image) {
                    // Get the edited MSB version with any drawings and legend
                    console.log('üìù Getting MSB canvas with drawings and legend...');
                    const editedImageDataURL = await getCanvasWithLegend('msb');
                    if (editedImageDataURL) {
                        console.log('üìä MSB Image data size:', Math.round(editedImageDataURL.length / 1024), 'KB');
                        formData.imageData = editedImageDataURL;
                    } else {
                        console.log('‚ö†Ô∏è Failed to get MSB canvas data, using original image');
                        formData.imageData = msbImageData;
                    }
                } else {
                    // Use original MSB image (no edits made)
                    console.log('üìã Using original MSB image data (no edits)...');
                    formData.imageData = msbImageData;
                }
            }
            
            // Get MCCB image data if available
            if (mccbImageData) {
                console.log('üñºÔ∏è Processing MCCB image data...');
                
                // Check if MCCB canvas has any content (image loaded)
                if (mccbCanvasState.image) {
                    // Get the edited MCCB version with any drawings and legend
                    console.log('üìù Getting MCCB canvas with drawings and legend...');
                    const editedImageDataURL = await getCanvasWithLegend('mccb');
                    if (editedImageDataURL) {
                        console.log('üìä MCCB Image data size:', Math.round(editedImageDataURL.length / 1024), 'KB');
                        formData.mccbImageData = editedImageDataURL;
                    } else {
                        console.log('‚ö†Ô∏è Failed to get MCCB canvas data, using original image');
                        formData.mccbImageData = mccbImageData;
                    }
                } else {
                    // Use original MCCB image (no edits made)
                    console.log('üìã Using original MCCB image data (no edits)...');
                    formData.mccbImageData = mccbImageData;
                }
            }
            
            // Disable button and show loading state
            const btn = document.getElementById('generateProposal');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Generating Proposal...';
            
            try {
                console.log('üöÄ Sending request to backend...');
                // Send request to backend
                const response = await fetch('/api/generate-proposal', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });
                
                console.log('üì® Response status:', response.status);
                
                if (response.ok) {
                    console.log('‚úÖ Response OK, handling file download...');
                    // Handle file download
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    
                    // Extract filename from response headers or use default
                    const contentDisposition = response.headers.get('Content-Disposition');
                    let filename = 'proposal.pptx';
                    if (contentDisposition) {
                        const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                        if (filenameMatch) {
                            filename = filenameMatch[1];
                        }
                    }
                    console.log('üìÅ Filename:', filename);
                    a.download = filename;
                    
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    alert('Proposal generated successfully! Download should start automatically.');
                    
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå Backend error:', errorText);
                    throw new Error(`Backend error: ${response.status} - ${errorText}`);
                }
                
            } catch (error) {
                console.error('‚ùå Error generating proposal:', error);
                alert(`Error generating proposal: ${error.message}`);
            } finally {
                // Re-enable button
                btn.disabled = false;
                btn.textContent = originalText;
            }
        });

        // Mobile touch optimization
        function preventDefaultTouch(e) {
            if (e.target.tagName === 'CANVAS') {
                e.preventDefault();
            }
        }
        
        // Tool button event listeners
        document.getElementById('selectTool').addEventListener('click', function() {
            currentDrawTool = null;
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = true;
            isDrawMode = true;
            updateDrawToolUI();
        });

        document.getElementById('trayTool').addEventListener('click', function() {
            currentDrawTool = 'tray';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('msTrunkingTool').addEventListener('click', function() {
            currentDrawTool = 'msTrunking';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('hdgTrunkingTool').addEventListener('click', function() {
            currentDrawTool = 'hdgTrunking';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('giPipeTool').addEventListener('click', function() {
            currentDrawTool = 'giPipe';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('corrugatedPipeTool').addEventListener('click', function() {
            currentDrawTool = 'corrugatedPipe';
            isEraserMode = false;
            isLogoMode = false;
            isSelectMode = false;
            updateDrawToolUI();
        });

        document.getElementById('logoTool').addEventListener('click', function() {
            // Simple check - just need to have at least one image uploaded
            if (!msbImageData && !mccbImageData) {
                alert('Please upload at least one image (MSB or MCCB) before adding logos.');
                return;
            }
            
            // If no canvas is currently selected, but we have images, prompt user
            if (!currentEditingType) {
                let message = 'Please select an image to edit first:\n\n';
                if (msbImageData) message += '‚Ä¢ Click "Edit MSB Image" to edit the MSB image\n';
                if (mccbImageData) message += '‚Ä¢ Click "Edit MCCB Image" to edit the MCCB image\n';
                alert(message);
                return;
            }
            
            currentDrawTool = null;
            isEraserMode = false;
            isLogoMode = true;
            isSelectMode = false;
            isDrawMode = true;
            updateDrawToolUI();
            
            // Show image gallery
            showImageGallery();
        });

        document.getElementById('eraserTool').addEventListener('click', function() {
            currentDrawTool = null;
            isEraserMode = true;
            isLogoMode = false;
            isSelectMode = false;
            isDrawMode = true;
            updateDrawToolUI();
        });

        // Gallery close button
        document.getElementById('closeGallery').addEventListener('click', function() {
            document.getElementById('imageGallery').classList.add('hidden');
        });

        // Place logo function for click placement
        function placeLogo(x, y) {
            // This will be called from the image gallery selection
            // The actual logo placement is handled in selectImage function
        }

        // Keyboard event handling for delete key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (isDrawMode && currentCanvas) {
                    const activeObject = currentCanvas.getActiveObject();
                    if (activeObject && activeObject.type === 'line' && activeObject !== currentCropRect && activeObject !== currentImage) {
                        currentCanvas.remove(activeObject);
                        currentCanvas.discardActiveObject();
                        currentCanvas.renderAll();
                        updateLegend(); // Update legend when object is deleted
                    }
                }
            }
        });

        // Initialize canvas on page load
        window.addEventListener('load', function() {
            initCanvases();
            
            // Prevent default touch behavior on canvas
            document.addEventListener('touchstart', preventDefaultTouch, { passive: false });
            document.addEventListener('touchmove', preventDefaultTouch, { passive: false });
            document.addEventListener('touchend', preventDefaultTouch, { passive: false });
            
            // Canvas responsive sizing is handled by CSS and separate canvas system
        });

        // Add some CSS for active tool styling
        const style = document.createElement('style');
        style.textContent = `
            .active-tool {
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                position: relative;
                z-index: 10;
            }
            .active-tool::after {
                content: '';
                position: absolute;
                inset: -2px;
                border-radius: inherit;
                background: linear-gradient(45deg, rgba(255,255,255,0.3), transparent);
                z-index: -1;
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>